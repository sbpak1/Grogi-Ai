# 🥊 Grogi AI 기획안 v3.2 (Final)

> 작성일: 2026년 2월 14일
> 개발 마감: 2026년 2월 20일

---

## 1. 프로젝트 개요

### 1.1 프로젝트명
Grogi AI

### 1.2 한 줄 소개
공감 대신 팩폭을 날리고, 실시간 데이터 기반의 현실적 액션 플랜을 제시하는 AI 에이전트. LangGraph + OpenAI Function Calling을 활용한 다단계 추론 구조로, 단순 챗봇이 아닌 자율적 에이전트로 동작한다.

### 1.3 문제 정의
현재 대부분의 AI 챗봇은 유저에게 공감과 위로를 주는 방식으로 설계되어 있다. 이는 사용자가 듣고 싶은 말만 듣게 되어 현실 직시를 방해하고, 실질적인 문제 해결로 이어지지 못하는 경우가 많다. Grogi AI는 이 문제를 정반대로 접근한다.

### 1.4 타겟 사용자
- 무비판적 공감보다 직설적인 피드백을 원하는 사람
- 취준생, 직장인, 프리랜서 등 커리어 고민이 있는 사람
- 연애, 재정, 자기개발 등 삶의 결정에서 현실 체크가 필요한 사람
- AI의 과장된 공감에 피로감을 느끼는 사람

---

## 2. 기존 LLM과의 차별점

| 구분 | 기존 LLM | Grogi AI |
|------|----------|----------|
| 응답 방식 | 사용자가 프롬프트 직접 작성 | 팩폭 → 팩트체크 → 액션플랜 3개 구조 강제 |
| 데이터 기반 | 학습 데이터 기반 일반 응답 | Function Calling + Tavily로 실시간 검색/통계 반영 |
| 에이전트 | 단순 입력 → 응답 | LangGraph 기반 다단계 추론 + 도구 자율 선택 |
| 인터랙션 | 톤 조절 없음 | 팩폭 레벨 슬라이더 (순한맛~핵불닭맛) |
| 결과 활용 | 대화 복사 정도 | 현실회피지수 0~100점 + SNS 공유카드 |
| 목적 | 범용 도구 | 고민 → 팩폭 + 해결책. 한 가지 목적 특화 |

---

## 3. AI 에이전트 아키텍처

LangGraph + OpenAI Function Calling 기반의 AI 에이전트.

### 3.1 LangGraph 그래프 구조

```
[START] → [crisis_check] → [analyze_input] → [select_tools] → [execute_tools] → [generate_response] → [END]
```

**crisis_check 노드 (필수 선행)**
- 모든 입력에 대해 무조건 먼저 실행. 에이전트 판단에 의존하지 않는 고정 선행 노드.
- 1차 키워드 필터링: 위험 키워드(자살, 죽고싶, 자해, 살고싶지않, 극단적 선택 등) 매칭.
- 2차 LLM 분석: 우회적 표현("다 끝내고 싶다", "의미가 없다" 등)을 GPT-4o로 문맥 분석.
- 위기 감지 시: 팩폭 모드 해제 → 따뜻한 톤 전환 → 전문 상담 안내 (자살예방 1393, 정신건강위기 1577-0199, 생명의전화 109)

### 3.2 에이전트 동작 흐름

| 단계 | 처리 | 설명 |
|------|------|------|
| Step 0 | 위기 감지 | 모든 입력에 무조건 실행. 키워드 + LLM 이중 체크 |
| Step 1 | 입력 분석 | 카테고리 판별 (커리어/연애/재정/자기개발/기타) |
| Step 2 | 도구 선택 | AI가 스스로 판단하여 필요한 도구 선택 및 호출 |
| Step 3 | 도구 실행 | Function Calling으로 웹 검색, 통계 조회 등 실행 |
| Step 4 | 결과 종합 | 검색 결과 + 입력 종합하여 팩폭 응답 생성 |
| Step 5 | 응답 출력 | 현실 진단 + 팩트 체크 + 액션 플랜 + 현실회피지수 구조화 출력 (SSE) |

### 3.3 Function Calling 설계

| Function 명 | 파라미터 | 설명 |
|-------------|----------|------|
| `search_web` | query: string | Tavily Search API 실시간 웹 검색 (무료 1,000회/월) |
| `get_statistics` | category, keyword | search_web 활용, 통계청/고용노동부/사람인 등 공신력 출처 우선 검색 |
| `calculate_reality_score` | user_message, context | 5가지 기준으로 현실회피지수 0~100 산출 (3.4절 참조) |
| `generate_share_card` | summary, score, actions | SNS 공유 카드 JSON 반환 → 프론트 html2canvas 렌더링 |

> `detect_crisis`는 Function Calling 도구가 아닌 LangGraph 필수 선행 노드로 동작 (3.1절)

### 3.4 현실 회피 지수 산출 기준

각 항목 0~20점, 합산 0~100점. 점수가 높을수록 현실 회피.

| 배점 | 평가 항목 | 판단 기준 | 예시 |
|------|-----------|-----------|------|
| 0~20 | 목표 현실성 | 목표와 현재 상황 간 괴리 | 6개월차인데 3년차 요구 포지션 → 높은 점수 |
| 0~20 | 노력 구체성 | 구체적 실행 계획 유무 | "열심히" vs "매일 2시간 코딩테스트" |
| 0~20 | 외부 귀인 경향 | 문제 원인을 외부로 돌리는 정도 | "회사가 문제" vs "내 실력 부족" |
| 0~20 | 정보 탐색 여부 | 관련 정보 실제 탐색 흔적 | "요건 몰라요" → 높은 점수 |
| 0~20 | 시간 긴박감 | 목표 대비 남은 시간 현실성 | "내년까지" 실제 3개월 남음 |

반환 형식:
```json
{
  "goal_realism": 18,
  "effort_specificity": 15,
  "external_blame": 12,
  "info_seeking": 17,
  "time_urgency": 14,
  "total": 76,
  "summary": "..."
}
```

### 3.5 검색 API 상세

- **search_web**: Tavily Search API — LangGraph 공식 통합 지원, 무료 1,000회/월, LLM 친화적 결과(URL + 요약 + 본문) 반환. 대안: Google Custom Search API, Serper API.
- **get_statistics**: 공공 데이터 기반 검색 — search_web(Tavily) 활용, 통계청/고용노동부/한국은행/사람인 등 신뢰 출처 우선 검색하도록 프롬프트에 명시.

---

## 4. 핵심 기능

### 4.1 팩폭 상담
- **현실 진단**: 사용자가 외면하는 불편한 진실
- **팩트 체크**: 실제 데이터/통계 기반 설명
- **액션 플랜**: 실행 가능한 구체적 행동 3가지

### 4.2 팩폭 레벨 시스템

| 레벨 | 톤 | 예시 |
|------|-----|------|
| 🔥 순한맛 (mild) | 솔직하지만 예의 있는 톤 | "솔직히 말하면..." |
| 🔥🔥 매운맛 (spicy) | 직설적이고 날카로운 톤 | "현실 직시해. ..." |
| 🔥🔥🔥 핵불닭맛 (extreme) | 완전 풀 팩폭 모드 | "야 진짜 남 애기하는 것 같지만..." |

### 4.3 현실 회피 지수 (0~100점)
`calculate_reality_score` 결과를 항목별 브레이크다운과 함께 시각화. SNS 공유 카드로 바이럴 장치 활용.

### 4.4 카테고리
- **커리어**: 취업, 이직, 취준, 프리랜서
- **연애**: 연애 고민, 이별, 썸
- **재정**: 투자, 저축, 소비 습관
- **자기개발**: 학습, 운동, 습관
- **기타**: 분류 불가 고민

### 4.5 카카오 로그인
카카오 OAuth 2.0 소셜 로그인. JWT 발급 후 인증 처리.

#### 4.5.1 카카오 로그인 플로우

카카오 JavaScript SDK를 프론트에서 사용하여 인가 코드를 받고, 백엔드에서 토큰 교환 후 JWT를 발급하는 구조.

1. 사용자가 프론트에서 "카카오로 시작하기" 버튼 클릭
2. 카카오 SDK가 카카오 인증 페이지로 리다이렉트
3. 사용자가 카카오 계정으로 로그인 후 인가 코드 발급
4. 프론트가 인가 코드를 `POST /api/auth/kakao`로 백엔드에 전송
5. 백엔드가 카카오 API에 인가 코드로 Access Token 요청
6. 카카오 Access Token으로 사용자 정보(kakao_id, nickname) 조회
7. users 테이블에 사용자 저장 (신규) 또는 조회 (기존)
8. JWT(Access Token) 발급하여 프론트에 반환
9. 프론트가 JWT를 Zustand 상태 + localStorage에 저장
10. 이후 모든 API 요청 시 `Authorization: Bearer {JWT}` 헤더 포함

**JWT 정책**: Access Token 만료 24시간. 해커톤 기간이므로 Refresh Token은 생략하고, 만료 시 재로그인 처리. JWT Payload에는 user_id, kakao_id, nickname을 포함.

### 4.6 SNS 공유 카드
`generate_share_card`가 JSON 반환 → 프론트 React 컴포넌트로 카드 렌더링 → html2canvas로 PNG 변환 → 이미지 저장 또는 URL 복사로 SNS 공유.

### 4.7 안전 장치
crisis_check 필수 선행 노드로 모든 입력을 검사. 상세는 3.1절 참조.

---

## 5. 기술 스택

| 구분 | 기술 | 설명 |
|------|------|------|
| Frontend | React 18 + Vite + TypeScript | 채팅 UI, 팩폭 레벨, 공유 카드 |
| CSS | Tailwind CSS | 빠른 스타일링 및 반응형 UI |
| 상태 관리 | Zustand | 로그인 상태, 채팅 히스토리, SSE 연결 상태 관리 |
| 공유 카드 | html2canvas | React 컴포넌트 → PNG 이미지 변환 |
| Backend | Node.js + Express | REST API, 인증, SSE 스트리밍 중계 |
| AI 에이전트 | Python + FastAPI + LangGraph | LangGraph StateGraph 기반 다단계 추론 |
| AI 모델 | OpenAI GPT-4o + Function Calling | 에이전트 핵심 추론 엔진 |
| 검색 API | Tavily Search API | AI 에이전트용 실시간 웹 검색 (무료 1,000회/월) |
| 인증 | 카카오 OAuth 2.0 + JWT | 소셜 로그인 + 24시간 Access Token |
| ORM | Prisma | DB 스키마 관리 및 타입 자동 생성 |
| DB | PostgreSQL | Railway 제공, 사용자/대화 로그 저장 |
| 스트리밍 | SSE (Server-Sent Events) | 에이전트 추론 과정 + 응답 실시간 스트리밍 |

---

## 6. DB 스키마 (Prisma)

### users

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|----------|------|
| id | String (uuid) | PK | 사용자 고유 ID |
| kakao_id | String | UNIQUE | 카카오 사용자 ID |
| nickname | String | | 카카오 닉네임 |
| created_at | DateTime | DEFAULT now() | 가입일 |

### sessions

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|----------|------|
| id | String (uuid) | PK | 세션 ID |
| user_id | String | FK → users.id | 사용자 참조 |
| category | String | | career/love/finance/self/etc |
| level | String | | mild/spicy/extreme |
| created_at | DateTime | DEFAULT now() | 세션 생성일 |

### messages

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|----------|------|
| id | String (uuid) | PK | 메시지 ID |
| session_id | String | FK → sessions.id | 세션 참조 |
| role | String | | user / assistant |
| content | Text | | 메시지 내용 |
| reality_score | Int? | nullable | assistant 메시지에만 저장 |
| score_breakdown | Json? | nullable | 항목별 점수 JSON |
| created_at | DateTime | DEFAULT now() | 생성일 |

### share_cards

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|----------|------|
| id | String (uuid) | PK | 카드 ID |
| message_id | String | FK → messages.id | 원본 메시지 참조 |
| summary | Text | | 팩폭 요약 |
| score | Int | | 현실 회피 지수 |
| actions | Json | | 액션플랜 3개 배열 |
| created_at | DateTime | DEFAULT now() | 생성일 |

---

## 7. 인프라 구성

| 구분 | 플랫폼 | 비고 |
|------|--------|------|
| Frontend | Cloudflare Pages | GitHub 연동 자동 배포 |
| Backend (Node.js) | Railway | Dockerfile 기반 |
| AI (Python) | Railway | Dockerfile 기반 |
| DB | Railway PostgreSQL | Railway 내장 DB |

**통신 흐름:**
```
[React] → (SSE) → [Node.js] → (HTTP Streaming) → [Python FastAPI + LangGraph] → [OpenAI API] / [Tavily API]
```

---

## 8. Node ↔ Python 내부 API 스펙

### 8.1 팩폭 요청

`POST /agent/chat` | `Content-Type: application/json`

**요청:**
```json
{
  "session_id": "string",
  "user_message": "string",
  "level": "mild|spicy|extreme",
  "category": "career|love|finance|self|etc",
  "history": [{"role": "string", "content": "string"}]
}
```

**응답:** `Content-Type: text/event-stream`

### 8.2 SSE 이벤트 타입

| event | 설명 | data 예시 |
|-------|------|-----------|
| status | 에이전트 추론 상태 | `{"step": "searching", "detail": "채용 정보 검색 중..."}` |
| token | 팩폭 응답 텍스트 스트리밍 | `{"content": "솔직히"}` |
| section | 응답 섹션 구분자 | `{"type": "diagnosis\|factcheck\|actionplan"}` |
| score | 현실 회피 지수 | `{"total": 76, "breakdown": {...}}` |
| share_card | 공유 카드 데이터 | `{"summary": "...", "score": 76, "actions": [...]}` |
| crisis | 위기 감지 안전 응답 | `{"message": "...", "hotlines": [...]}` |
| error | 에러 | `{"code": "TOOL_FAILED", "message": "..."}` |
| done | 스트림 종료 | `{}` |

### 8.3 SSE 중계 방식 (Node.js)

Node.js는 Python SSE 응답을 받아서 파싱 후 처리한다. 단순 파이프가 아닌 파싱 후 재전송 방식.

- **token, status, section, crisis** 이벤트: 파싱 없이 프론트에 그대로 전달 (pass-through)
- **score** 이벤트: 파싱 → messages 테이블에 reality_score, score_breakdown 저장 → 프론트 전달
- **share_card** 이벤트: 파싱 → share_cards 테이블에 저장 → 프론트 전달
- **done** 이벤트: 전체 응답 텍스트를 messages 테이블에 저장 → 프론트 전달 → SSE 연결 종료
- **error** 이벤트: 에러 로깅 → 프론트 전달

### 8.4 헬스체크 및 타임아웃

- `GET /agent/health` → `{ status, model, tavily }`. Node가 30초 간격으로 호출.
- 팩폭 요청 타임아웃: 60초. 초과 시 프론트에 "응답 생성 시간 초과" 안내.
- Function Calling 실패 시: 학습 데이터 기반 폴백 응답 + "실시간 데이터 없이 응답" 안내.

---

## 9. 응답 출력 포맷

### 스트리밍 순서

1. **status** 이벤트: "검색 중...", "통계 조회 중...", "팩폭 생성 중..." (프론트에서 로딩 상태로 표시)
2. **section** `{type: "diagnosis"}` → **token** 스트림 (현실 진단 텍스트)
3. **section** `{type: "factcheck"}` → **token** 스트림 (팩트 체크 텍스트)
4. **section** `{type: "actionplan"}` → **token** 스트림 (액션 플랜 텍스트)
5. **score** 이벤트 (현실 회피 지수 + 브레이크다운)
6. **share_card** 이벤트 (공유 카드 데이터)
7. **done** 이벤트 (종료)

### 프론트 UI 매핑

- **diagnosis** 섹션 → 빨간색/경고 톤의 카드 UI
- **factcheck** 섹션 → 데이터/통계 강조 UI (인용 스타일)
- **actionplan** 섹션 → 번호가 매겨진 리스트 UI
- **score** → 도넛/바 차트 시각화 컴포넌트
- **share_card** → 공유 카드 컴포넌트 + 이미지 저장/URL 복사 버튼

---

## 10. 외부 API 설계

프론트 ↔ Node.js 백엔드 간 API. Node ↔ Python은 8절 참조.

| Method | Endpoint | 설명 |
|--------|----------|------|
| POST | /api/auth/kakao | 카카오 인가 코드 → JWT 발급 |
| POST | /api/chat | 팩폭 요청 (SSE 응답) [인증] |
| GET | /api/chat/{sessionId} | 대화 히스토리 조회 [인증] |
| POST | /api/share | 공유 카드 데이터 조회 [인증] |

---

## 11. 팀 구성 및 역할

| 역할 | 담당 업무 |
|------|-----------|
| Backend | Node.js + Express API, 카카오 OAuth + JWT, SSE 중계 (파싱+DB저장+전달), PostgreSQL + Prisma, Docker + Railway 배포 |
| Frontend | React + Vite + TypeScript + Zustand, 채팅 UI + SSE 연동, 팩폭 레벨/카테고리 UI, 섹션별 응답 UI, 결과 카드 + html2canvas, Cloudflare Pages |
| AI | LangGraph StateGraph + crisis_check 선행 노드, 시스템 프롬프트 설계/튜닝, Tavily + Function Calling 도구, 현실회피지수 산출, FastAPI SSE + Railway |

---

## 12. 프로젝트 구조 (GitHub 모노레포)

```
grogi-ai/
├── frontend/          # React + Vite (Cloudflare Pages)
│   ├── src/
│   │   ├── stores/    # Zustand 스토어 (auth, chat)
│   │   ├── components/
│   │   └── hooks/     # useSSE 등 커스텀 훅
│   ├── package.json
│   └── vite.config.ts
├── backend/           # Node.js + Express (Railway)
│   ├── src/
│   ├── prisma/        # Prisma 스키마
│   ├── package.json
│   └── Dockerfile
├── ai/                # Python + FastAPI + LangGraph (Railway)
│   ├── app/
│   │   ├── agent/     # LangGraph 그래프 + 노드
│   │   ├── tools/     # search_web, get_statistics 등
│   │   └── prompts/   # 시스템 프롬프트 템플릿
│   ├── requirements.txt
│   └── Dockerfile
├── .gitignore
└── README.md
```

---

## 13. 환경 변수

### Backend (Node.js)

| 변수명 | 설명 |
|--------|------|
| DATABASE_URL | PostgreSQL 연결 URL (Railway 제공) |
| KAKAO_CLIENT_ID | 카카오 앱 REST API 키 |
| KAKAO_CLIENT_SECRET | 카카오 앱 Secret Key |
| KAKAO_REDIRECT_URI | 카카오 로그인 콜백 URL |
| JWT_SECRET | JWT 서명 비밀키 |
| AI_SERVER_URL | Python AI 서버 주소 (Railway 내부 URL) |
| PORT | 서버 포트 (Railway 자동 할당) |

### AI Server (Python)

| 변수명 | 설명 |
|--------|------|
| OPENAI_API_KEY | OpenAI API 키 |
| TAVILY_API_KEY | Tavily Search API 키 |
| PORT | 서버 포트 (Railway 자동 할당) |

### Frontend

| 변수명 | 설명 |
|--------|------|
| VITE_API_URL | Node.js 백엔드 API URL |
| VITE_KAKAO_JS_KEY | 카카오 JavaScript 키 (프론트 SDK용) |

> 모든 키는 .env 파일로 관리하고, 절대 GitHub에 커밋하지 않는다. 팀원 간에는 DM으로 공유.

---

## 14. 시스템 프롬프트 설계

### 14.1 기본 페르소나
"솔직한 형/누나가 후배한테 말하는 느낌". 인신공격 금지, 상황과 행동에 대해 날카로운 피드백.

### 14.2 핵심 규칙
- **공감 표현 금지**: "힘들었겠다", "충분히 그럴 수 있어" 등 금지
- **현실 진단 필수**: 불편한 진실 반드시 짚어줄 것
- **데이터 기반 필수**: 검색/통계 있으면 반드시 인용
- **액션 플랜 필수**: 구체적 행동 3가지 제시
- **인신공격 금지**: 상황과 행동만 비판
- **위기 감지**: crisis_check 결과에 따라 팩폭 모드 해제

### 14.3 레벨별 프롬프트 변형
- **순한맛**: 존중어 사용
- **매운맛**: 직설적 표현 강화
- **핵불닭맛**: 반말 + 직설 극대화

---

## 15. 화면 구성

### 15.1 메인 채팅 화면
- **상단**: 로고 + 서비스 소개 + 로그인/로그아웃 버튼
- **중앙**: 채팅 영역 (에이전트 상태 + 섹션별 응답 UI)
- **하단**: 입력창 + 팩폭 레벨 슬라이더 + 카테고리 선택

### 15.2 결과 카드 (공유용)
- 팩폭 요약 + 현실회피지수 (항목별 브레이크다운) + 액션플랜 3개
- 이미지 저장 (html2canvas) / URL 복사 버튼

---

## 16. 개발 일정

총 7일 (2/13~2/20). 순수 개발: Day 3~6 (4일).

| 날짜 | 구분 | 작업 내용 |
|------|------|-----------|
| Day 1 (2/13) | 기획 + 세팅 | 기획안 확정, GitHub 모노레포, 프로젝트 초기 세팅, API 키 발급 |
| Day 2 (2/14) | 에이전트 + 스펙 | ★ Node ↔ Python API 스펙 합의, ★ SSE 이벤트 타입/포맷 확정, ★ 프론트 ↔ 백엔드 API 포맷 확정, LangGraph 설계 + crisis_check 구현, 시스템 프롬프트 초안 + Function 정의 |
| Day 3 (2/15) | 백엔드 API | 카카오 OAuth + JWT, /api/chat SSE 중계, Prisma 스키마 + DB, 공유 카드 API |
| Day 4 (2/16) | 프론트 핵심 | 채팅 UI + SSE 연동 + 섹션별 응답 UI, 팩폭 레벨/카테고리 UI, 로그인 UI |
| Day 5 (2/17) | 프론트 + 디자인 | 결과 카드 + html2canvas + SNS 공유, 현실회피지수 시각화, UI/UX 디자인 |
| Day 6 (2/18) | 통합 + 영상 | 통합 테스트 + 엣지케이스, 배포 환경 구성, ★ 시연 영상 촬영 시작 (OBS 녹화 + CapCut 편집) |
| Day 7 (2/19~20) | 배포 + 마무리 | 배포 + 버그픽스 + 시연영상 최종편집 + 제출 |

> ★ Day 2 필수 합의: Node ↔ Python API 스펙, SSE 이벤트 타입, 프론트 ↔ 백엔드 API 포맷. 이 3가지 미합의 시 Day 3부터 병목.

---

## 17. 시연 영상 (3분)

### 17.1 촬영 도구
- 화면 녹화: OBS Studio (무료, 화면 + 음성 동시 녹화)
- 편집: CapCut (무료, 자막 자동 생성) 또는 Vrew (무료, 음성 기반 자막)
- 해상도: 1920x1080 (1080p), 포맷: MP4

### 17.2 영상 구성

| 구간 | 내용 |
|------|------|
| 0:00~0:20 | Grogi AI 소개 (한 줄 컨셉 + 화면) |
| 0:20~1:20 | 커리어 시나리오 + 에이전트 추론 과정 + 팩폭 레벨 변경 |
| 1:20~2:10 | 연애 시나리오 (카테고리별 다른 동작) |
| 2:10~2:40 | 현실회피지수 + 공유카드 생성 + 이미지 저장 |
| 2:40~3:00 | 위기 감지 안전장치 + 마무리 |

---

## 18. 리스크 및 대응 방안

| 리스크 | 영향도 | 대응 |
|--------|--------|------|
| OpenAI API 검열 | 높음 | 팩폭 강도 조절 + 프롬프트 다층 설계 |
| 위기 상황 미감지 | 매우 높음 | crisis_check 선행노드 + 키워드/LLM 이중 |
| Function Calling 불안정 | 중간 | 실패 시 학습데이터 폴백 |
| Node ↔ Python 통신 장애 | 중간 | 헬스체크(30s) + 타임아웃(60s) + 로깅 |
| Tavily 할당량 초과 | 낮음 | 1,000회/월. 초과 시 학습데이터 폴백 |
| 사용자 불쾌 반응 | 중간 | 레벨 조절로 사용자 선택 |
| OpenAI 비용 초과 | 중간 | 일일 사용량 제한 + 캐싱 |

---

## 19. 향후 확장 가능성

- 음성 모드: Whisper + TTS
- 팩폭 아카이브: 과거 기록 + 성장 추적 대시보드
- 커뮤니티: 다른 사용자 팩폭 피드
- 특화 모드: 이력서/포트폴리오/사업계획서 팩폭
- 멀티 에이전트: 팩폭 + 위로 에이전트 토론 구조
- 다국어 지원: 영어, 일본어 팩폭 모드
